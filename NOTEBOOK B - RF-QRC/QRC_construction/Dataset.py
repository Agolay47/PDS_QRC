import numpy as np
from qiskit.quantum_info import Statevector, Operator, Pauli, DensityMatrix
from qiskit import QuantumCircuit
import pandas as pd
from qiskit.quantum_info import random_statevector
from itertools import product


def generate_random_circuit(nb_qubits, depth, seed=None):
    """
    Generate a random quantum circuit for a given number of qubits and depth.

    Parameters:
    nb_qubits (int): The number of qubits in the quantum circuit.
    depth (int): The depth of the quantum circuit.
    seed (int, optional): The seed for the random number generator.

    Returns:
    qc (QuantumCircuit): The generated quantum circuit.

    Notes:
    The quantum circuit is generated by randomly applying 1-qubit rotations to each qubit and entangling adjacent qubits.
    """

    if seed is None:
        seed = np.random.randint(0, 1000)
    rng = np.random.default_rng(seed)
    
    qc = QuantumCircuit(nb_qubits)

    # Loop over the given number of layers
    for d in range(depth):
        # Loop over the number of qubits and apply 1-qubit rotations
        for q in range(nb_qubits):
            # Generate random angles for RX, RY and RZ
            alpha, beta, gamma = rng.uniform(0, 2*np.pi, size=3)
            # Apply RX, RY and RZ to the qubit
            qc.rx(alpha, q)
            qc.ry(beta, q)
            qc.rz(gamma, q)
        # Entangle adjacent qubits
        for q in range(0, nb_qubits - 1, 2):
            # Entangle adjacent qubits
            qc.cx(q, q + 1)
    return qc

def generate_random_hamiltonian(nb_qubits, time_indep=False, seed=None, max_terms_expr=10):
    """
    Generate a random n-qubit Hamiltonian.

    Parameters:
    nb_qubits (int): The number of qubits in the Hamiltonian.
    time_indep (bool, optional): If True, generate a time-independent Hamiltonian.
                                 If False, generate a time-dependent Hamiltonian.
    seed (int, optional): The seed for the random number generator.
    max_terms_expr (int, optional): The maximum number of terms to include in the expression.

    Returns:
    H_obj (qiskit.Operator or callable):
        If time_dependent is False: a qiskit.Operator for a fixed Hamiltonian.
        If time_dependent is True : a callable H_of_t(t) returning an Operator.
    expr (str):
        A human-readable expression of the Hamiltonian in the Pauli basis.
        For time-dependent H(t), expr describes H0 and H1 such that
        H(t) = H0 + sin(t) H1.
    """
    if seed is None:
        seed = np.random.randint(0, 1000)
    rng = np.random.default_rng(seed)

    dim = 2 ** nb_qubits

    def random_hermitian_matrix():
        """
        Generate a random traceless Hermitian matrix of size dimxdim,
        using rng_local.
        """
        A = rng.normal(size=(dim, dim)) + 1j * rng.normal(size=(dim, dim))
        H = 0.5 * (A + A.conj().T)
        trace = np.trace(H) / dim
        H = H - trace * np.eye(dim, dtype=complex)
        return H

    def pauli_decomposition(H, max_terms=max_terms_expr, tol=1e-10):
        """
        Decompose H into the n-qubit Pauli basis and return a string.
        H is a (2^n x 2^n) numpy array.
        """
        labels = [''.join(p) for p in product('IXYZ', repeat=nb_qubits)]
        coeffs = []
        for label in labels:
            P = Pauli(label).to_matrix()
            c = np.trace(P.conj().T @ H) / dim  # coefficient in Pauli basis
            c = np.real_if_close(c)
            if np.abs(c) > tol:
                coeffs.append((label, float(np.real(c))))
        coeffs.sort(key=lambda x: abs(x[1]), reverse=True)

        if max_terms is not None:
            coeffs = coeffs[:max_terms]

        if not coeffs:
            return "H ≈ 0"

        out = ["H ≈ "]
        first = True
        for label, c in coeffs:
            sgn = "+" if c >= 0 else "-"
            val = abs(c)
            if first:
                out.append(f"{c:.4f} * {label}")
                first = False
            else:
                out.append(f" {sgn} {val:.4f} * {label}")
        return "".join(out)

    # main part
    if not time_indep:
        # H(t) = H0 + sin(t) H1
        H0 = random_hermitian_matrix()
        H1 = random_hermitian_matrix()

        def H_of_t(t):
            return Operator(H0 + np.sin(t) * H1)

        expr_H0 = pauli_decomposition(H0)
        expr_H1 = pauli_decomposition(H1)

        expr = (
            "H(t) = H0 + sin(t) * H1\n"
            "where\n"
            f"{expr_H0}\n"
            f"{expr_H1}"
        )

        return H_of_t, expr

    else:
        # time-independent
        H = random_hermitian_matrix()
        H_op = Operator(H)
        expr = pauli_decomposition(H)
        return H_op, expr


def unitary_from_hamiltonian(H_mat, dt=1.0):
    """
    Compute the unitary matrix U from the Hamiltonian matrix H.

    Parameters:
    H_mat (numpy.ndarray of shape (dim, dim)): The Hamiltonian matrix.
    dt (float): The time step. Default is 1.0.

    Returns:
    U (numpy.ndarray of shape (dim, dim)): The unitary matrix U.
    """
    H_mat = np.asarray(H_mat, dtype=complex)
    # Compute eigenvalues and eigenvectors of H
    w, V = np.linalg.eigh(H_mat)
    # Compute phases from eigenvalues
    phases = np.exp(-1j * w * dt)
    # Compute unitary matrix U from eigenvectors and phases
    U = V @ np.diag(phases) @ V.conj().T
    return U

def dataset_from_quantum_circuit(T, qc, init_state=None, seed=None):
    """
    Generate a dataset of states from a quantum circuit.

    Parameters:
    T (int): The number of time steps.
    qc (QuantumCircuit): The quantum circuit.
    init_state (Statevector): The initial state. If None, a random initial state is generated.
    seed (int): The random seed used to generate the initial state. If None, a random seed is used.

    Returns:
    states (List[Statevector]): The list of states at each time step.
    """
    U = Operator(qc).data
    nb_qubits = qc.num_qubits
    if init_state is None:
        if seed is None:
            seed = np.random.randint(0, 2**16)
        init_state = random_statevector(2**nb_qubits, seed=seed)
    states = [init_state]
    for _ in range(1, T):
        vec = U @ states[-1].data
        states.append(Statevector(vec))
    return states

def dataset_from_time_indep_H(T, H, dt, init_state=None, seed=None):
    """
    Generate a dataset of states from a time-independentHamiltonian matrix.

    Parameters:
    T (int): The number of time steps.
    H (numpy.ndarray): The time-independentHamiltonian matrix.
    dt (float): The time step.
    init_state (Statevector): The initial state. If None, a random initial state is generated.
    seed (int): The random seed used to generate the initial state. If None, a random seed is used.

    Returns:
    states (List[Statevector]): The list of states at each time step.
    """
    U = unitary_from_hamiltonian(H, dt=dt)
    nb_qubits = H.num_qubits
    if init_state is None:
        if seed is None:
            seed = np.random.randint(0, 2**16)
        init_state = random_statevector(2**nb_qubits, seed=seed)
    states = [init_state]
    for _ in range(1, T):
        vec = U @ states[-1].data
        states.append(Statevector(vec))
    return states

def dataset_from_time_dep_H(T, H, dt, nb_qubits,init_state=None, seed=None):
    """
    Generate a dataset of states from a time-dependentHamiltonian matrix.

    Parameters:
    T (int): The number of time steps.
    H (function): The time-dependentHamiltonian function.
    dt (float): The time step.
    nb_qubits (int): The number of qubits.
    init_state (Statevector): The initial state. If None, a random initial state is generated.
    seed (int): The random seed used to generate the initial state. If None, a random seed is used.

    Returns:
    states (List[Statevector]): The list of states at each time step.
    """
    if init_state is None:
        if seed is None:
            seed = np.random.randint(0, 2**16)
        init_state = random_statevector(2**nb_qubits, seed=seed)

    states = [init_state]

    for k in range(1, T):
        # Computing the time-dependent Hamiltonian matrix at time t_k
        t_k = (k - 1) * dt
        H_t = H(t_k)

        # Converting the time-dependent Hamiltonian matrix to a numpy array
        if isinstance(H_t, Operator):
            # Converting the Operator to a numpy array
            H_mat = H_t.data
        else:
            H_mat = np.asarray(H_t, dtype=complex)

        U = unitary_from_hamiltonian(H_mat, dt=dt)
        # Computing the next state (by applying the unitary matrix U)
        vec = U @ states[-1].data
        states.append(Statevector(vec))
    return states

def narma_dataset(T, order, seed=None, washout=None):
    """
    Generate a dataset from a NARMA model.

    Parameters:
    T (int): The number of time steps.
    order (int): The order of the NARMA model.
    seed (int): The random seed used to generate the dataset. If None, a random seed is used.
    washout (int): The washout period. If None, it is set to 10*order.

    Returns:
    y (numpy.ndarray): The dataset.
    """
    if seed is None:
        seed = np.random.randint(0, 1000)
    
    rng = np.random.default_rng(seed)

    # Set the washout period (typically defined as 10*order)
    if washout is None:
        washout = 10*order

    u = rng.uniform(0.0, 0.5, size=T+washout)
    y = np.zeros(T+washout, dtype=float)
    for t in range(order, T+(washout-1)):
        # Compute the next value of the NARMA model
        sum_term = 0.0
        for i in range(order):
            # Sum over the previous values
            sum_term += y[t - i]
        # Compute the next value as a linear combination of the previous values and the external drive/noise
        y[t+1] = (
            0.3 * y[t]  # linear term
            + 0.05 * y[t] * sum_term  # nonlinear term
            + 1.5 * u[t - order] * u[t]  # external drive term
            + 0.1  # bias term
        )
    return y[washout:]
    
def tomato_dataset(T):
    """
    Load tomato prices from a Kaggle 'Tomato Daily Prices' CSV and return
    a 1D array of the first T prices (oldest -> newest), using only columns
    whose name contains the substring 'price' (case-insensitive).

    Parameters:
    T (int): Number of values to return (max).

    Returns:
    y (np.ndarray, shape (N,)): N <= T daily prices, sorted by Date
    """
    csv_path = "datasets/Tomato.csv"

    # Loading CSV
    df = pd.read_csv(csv_path)

    date_cols = [c for c in df.columns if c.lower() == "date"]
    if date_cols:
        date_col = date_cols[0]
        df[date_col] = pd.to_datetime(df[date_col], errors="coerce")
        df = df.sort_values(date_col)

    # Selecting columns whose name contains 'price'
    price_cols = [c for c in df.columns if "average" in c.lower()]

    if not price_cols:
        raise ValueError(
            "No columns with 'price' in their name were found.\n"
            f"Available columns: {list(df.columns)}"
        )

    # Converting those columns to numeric
    df_price = df[price_cols].apply(pd.to_numeric, errors="coerce")

    # If multiple price columns: we need to take row-wise mean (ignore NaN)
    if len(price_cols) == 1:
        y_all = df_price.iloc[:, 0].to_numpy(dtype=float)
    else:
        y_all = df_price.mean(axis=1, skipna=True).to_numpy(dtype=float)

    # Drop all NaNs
    y_all = y_all[~np.isnan(y_all)]

    # Clip to T
    if T > len(y_all):
        print(
            f"[get_kaggle_tomato_prices] Requested T={T}, "
            f"but only {len(y_all)} values available; returning {len(y_all)}."
        )
        T = len(y_all)

    return y_all[:T]


def lorenz63_dataset(T, seed=None, sigma=10.0, rho=28.0, beta=8.0/3.0, dt=0.01, washout=1000):
    """
    Generate a dataset from the Lorenz63 dynamical system.

    Parameters:
    T (int): The number of time steps.
    seed (int, optional): The random seed used to generate the initial state. If None, a random seed is used.
    sigma (float, optional): The value of the sigma parameter in the Lorenz 63 dynamical system. Default is 10.0.
    rho (float, optional): The value of the rho parameter in the Lorenz 63 dynamical system. Default is 28.0.
    beta (float, optional): The value of the beta parameter in the Lorenz 63 dynamical system. Default is 8.0/3.0
    dt (float, optional): The time step. Default is 0.01 (by far the most common choice in literature).
    washout (int, optional): The washout period to avoid transient behavior. Default is 1000.

    Returns:
    traj (numpy.ndarray of shape (T, 3)): The dataset generated from the Lorenz63 dynamical system.
    """
    rng = np.random.default_rng(seed)
    # modest random init (avoid huge values)
    x0 = rng.normal(loc=0.0, scale=1.0, size=3)

    def f(state):
        x, y, z = state
        return np.array([
            sigma * (y - x),
            x * (rho - z) - y,
            x * y - beta * z
        ], dtype=float)

    total_steps = washout + T
    traj = np.zeros((total_steps, 3), dtype=float)
    traj[0] = x0

    for t in range(total_steps - 1):
        s = traj[t]
        k1 = f(s)
        k2 = f(s + 0.5 * dt * k1)
        k3 = f(s + 0.5 * dt * k2)
        k4 = f(s + dt * k3)
        traj[t + 1] = s + (dt / 6.0) * (k1 + 2*k2 + 2*k3 + k4)

    return traj[washout:]  # (T, 3)
